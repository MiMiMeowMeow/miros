*Complete Re-write of Miros*

= Observe =
  *What defines Success?*
  
  *Notes:*
  statecharts = state-diagrams + depth + orthogonality +
                broadcast-communications + time 
 
  1) "in all airborne state, when yellow handle is pulled seat will be ejected"
  2) "gearbox change state is independent of breaking system"
  3) "when selection button is pressed enter selected mode"
  4) "display-mode consists of time-display, data-display and stopwatch-display"

  1 calls for ability to cluster events into super states
  2 introduces the idea of independence or orthogonality
  3 more general transition than a signal event-labelled arrow[?]
  4 captures the refinement of states[?]
  
  The idea of zooming ... Focusing into the detail of an aspect of the system.
  Even though I know what they are talking about, the paper is hard to read.
  
  By using this library you are in better shape to use the quantum programming
  library, since it is using the same concepts and similar event processor.
  
  In the writing talk about cognitive load
  
  
  An understandable heart to the miros python package
  * [o] Immediate Plans
    * [ ] Glossary
    * [ ] Simple Set of Hsms in active objects communicating with the active fabric

  * [.] High Level Project List
    * [O] Basic Examples
      * [ ] Simple Set of Hsms in active objects communicating with the active fabric
    * [ ] Add Pattern Support (with and without the factory)
      * [ ] Ultimate Hook
      * [ ] Add outside ultimate hook feature
      * [ ] Reminder
      * [ ] Deferred Event
      * [ ] Orthogonal Component
      * [ ] Transition to State History
      * [ ] Multi-Chart Race
      * [ ] Multi-Chart Pend
      * [ ] Linking to redis
    * [o] Recipes
      * [ ] Context descriptions... an active object has a thread and consists
            of a bunch of state methods, the state methods are blah blah and
            have events ... reflection... testing... blah blah
      * [ ] Creating an active object
      * [ ] Starting an active object
      * [ ] sub/pub model with two different charts
    * [ ] Roll up into package miros 2.0.0

  *Weird and Fun Ideas*
    * [ ] Add statistics
    * [ ] Create a sampler
    * [ ] Add rule 33 and some other Wolfram goodies
    * [ ] Self organizing criticality
    * [ ] The devil's staircase
    * [ ] Turn on/off spy within a subset of the chart [recipe]
  
  *House Keeping:*
    * [ ] Make sure all examples are backed by running code in the tests files
          
  *Someday Maybe*
    * [ ] Add timestamps to spy
    * [ ] Research Protocol Theory
    * [ ] A message/protocol as a chart
  
  *Resources:*
  Setting up a python project is needlessly complicated, but here are the steps:
  * [ ] Move your production files into a subdirectory, named after your project
        (miros)
  * [ ] Add a setup.py file at the same level as this directory
  * [ ] Install virtualenv
  * [ ] > virtualenv <whatever> # in this case: > virtualenv prot
  * [ ] In bash > source ./prot/Scripts/activate
  * [ ] In the named subdirectory, (miros), add a file called __init__.py, this
        turns it into a package.  Your test code will be able to import files
        into themselves like:  from miros.events import <Class>
  * [ ] Add a test directory
  * [ ] Name your tests as <whatever>_test.py
  * [ ] In the test files your imports should work
  * [ ] Install your local package > pip install --editable .
  * [ ] Write a super simple test that just fails with tries to import something
        from your package.  Test it with > pytest, confirm failure from assert
        not an import error.
  * [ ] Wrestle with it until it works.

  *What is the problem?*

  *Evidence that contradicts Assumptions:*

= Orient =
  *Symptoms of current issue:*
  
  *Questions regarding current issue:*

  *Assumptions:*

= Decide =
  *Idea/Hypothesises: >=5*

  *Chosen Idea/Hypothesis*

  *Plan to Expand-on-Idea/Disprove-Hypothesis*

= Act =

