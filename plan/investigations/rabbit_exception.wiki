*Rabbit Disconnection Exception*
= Observe =
  *What defines Success?*
  A working re-write of miros-rabbitmq using the the pika async example code. 
    
  *Immediate Goal*
    Demonstrate (two different versions using different HSM classes of)
    two small ergotic HSMs that can communicate between each other from
    different processes on the same machine (use WLS).  From within this
    example, demonstrate that the mesh is working, that the spy snoop is working
    and the trace snoop is working.
 
  *Problem*
    We are using a completely new code base; The snoop network has been broken
    into two parts, the topic subscription scheme is different from the previous
    version of the software.
    
    The new framework should work for multiple classes in the miros stack (Factory,
    Active Object, Hsm with Queues).  To know if it actually works we need to
    try these.
    
    The snoop spy results will be extremely noisy.
    
    The small ergotic HSM needs to be designed.
  
  *Evidence that informs Assumptions:*
  
= Orient/Homework/Empathy =
  *Information about the current context*
    The pi exchange: http://192.168.1.69:15672/#/exchanges
    The WLS exchange: http://127.0.0.1:15672/#/exchanges
    
    Go on a functool vacation.  This looks really useful, you should know more
    about it.
    
   *Feature Visions*: 
      *Producer*:
      *Consumer*:
      *Scout*
      *Mesh*
      *Snoop*:
      * [ ] Add coloring from different machines
      * [ ] Add spy filtering
      *Integration*
      * [O] MirosNets (change this name to something better)
        * [X] get minimal active object example working
        * [X] add snoop trace
        * [X] add snoop spy
        * [X] clean
        * [X] remake it with the factory
        * [X] draw your work
        * [X] create new miros-rabbitmq package
        * [X] confirm that the package is working
        * [X] test across network
        * [ ] change the networked_horse_archer.py to use new design
        * [ ] document the docstring of MirosNets
        * [ ] create an example:
          * [ ] ActiveObject which uses it
          * [ ] Factory which uses it
        * [ ] re-write all docs :(
  
  *History*
    My botnet was working, based on an old and unreliable way of using pika
    (from RabbitMq docs).  
    
    But this code would fail after running for > 15 minutes.  The time-to-test
    was too long to troubleshoot comfortably, so I decided to re-write
    everything based on the pika project's stable example.  Errors seen in my
    previous version:
    
      One two bots (WSL):
        pika.exceptions.ConnectionClosed: (-1, "ConnectionResetError(104, 'Connection reset by peer')")
      
      The other two bots:
        pika.exceptions.ChannelClosed
        
    So, there needs to be a number of resets and other complications that were
    not talked about in the RabbitMq-pika training examples. (My old code is
    broken and the testing cycle takes > 15 minutes)
    
    To avoid this problem again I will use the pika documentation's complicated
    pika-asyncronous example as a starting point, then wrap it with the
    functionality required for miros-rabbitmq.  Once again, you can't trust the
    dom.
  
  *Symptoms:*
  
  *Questions for Rabbit Disconnection Exception:*
    What don't I know that I need to know?
    Am I going to review this process when I have finished it?
    Can I Improve this process?
    Can I make better decisions this time?

  *Assumptions:*

= Decide =
  *Idea/Hypotheses for Rabbit Disconnection Exception: >=5*
  * [X] Build something with a randomizing one shot (1-3 seconds)
  * [X] Have it switch states so we can see if it works
  * [X] Get the mesh to spit something to another mesh
  * [X] Run two instances of the program to see if this works
  * [X] Turn off the mesh threads while transmitting, then turn them on and
        confirm that the software can recover. (WLS<->WLS)
  * [X] Turn off the mesh threads while transmitting, then turn them on and
        confirm that the software can recover. (WLS<->pi)
  * [X] Create a custom listener callback
  * [ ] See if you can get a statechart to hear something from a mesh output
  * [ ] See if you can get a statechart to yell something to a mesh input
  * [ ] Create a subclass of ActiveObject which can use the mesh
  * [ ] Have this subclass transmit and receive messages from two instances of
        itself using the race pattern
  * [ ] Use local trace to see if the mesh is working [debug]
  * [ ] Turn on the snoop trace [debug]
  * [ ] Turn on the snoop spy [debug]
  * [ ] Add colors for snoop traces from other machines [debug]
  * [ ] Add spy filters [debug]
  * [ ] Create three versions of this statechart using the three available
        classes.
  * [ ] Create new immediate goal for this plan
  * [ ] Add code to miros-rabbitmq and release package
  * [ ] Use this pack in the horse archer example [debug]
  * [ ] Re-write documentation
  * [ ] Write up miros-rabbitmq documentation
  
  *Chosen Idea/Hypothesis*
   
  *Plan to Expand-on-Idea/Disprove-Hypothesis*

= Act =

