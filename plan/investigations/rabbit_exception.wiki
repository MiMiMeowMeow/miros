*Rabbit Disconnection Exception*
= Observe =
  *What defines Success?*
    A working re-write of miros-rabbitmq using the the pika async example code. 
    
  *Immediate Goal:*
    * [X] Callback mechanism to be issued when a message is received
  
  *Immediate problem?*
    Added the ability to change the encryption key, encryption/decryption
    function and serialization/deserialization function (needed for miros).  This
    code needs to be documented (tedious work)
    
  *Global problem?*
    My botnet was working, based on an old and unreliable way of using pika
    (from RabbitMq docs).  
    
    But this code would fail after running for > 15 minutes.  The time-to-test was
    too long to troubleshoot that approach, so I decided to re-write everything to
    work from the pika project's stable example.  Errors seen in my previous version:
    
      One two bots (WSL):
        pika.exceptions.ConnectionClosed: (-1, "ConnectionResetError(104, 'Connection reset by peer')")
      
      The other two bots:
        pika.exceptions.ChannelClosed
        
    So, there needs to be a number of resets and other complications that were
    not talked about in the RabbitMq-pika training examples. (My old code is
    broken and the testing cycle takes > 15 minutes)
    
    To avoid this problem again I will use the pika documentation's complicated
    pika-asyncronous example as a starting point, then wrap it with the
    functionality required for miros-rabbitmq

  *Evidence that informs Assumptions:*
  
  Previous issues:
  
= Orient =
  *Information about the current context*
    Go on a functool vacation.  This looks really useful, you should know more
    about it.
    
    The consumer will be on the pi
    
    The producer will be on the WLS
    
    The user/password will be the same as before
    
    The exchange is defined by the consumer, the producer's machine does not have the exchange
    
    The pi exchange: http://192.168.1.69:15672/#/exchanges
    The WLS exchange: http://127.0.0.1:15672/#/exchanges
    
    With PUBLISH_INTERVAL = 0.00000000000000000000001 their example ran for 5 minutes with no issues
    
    There is some mention about RPC calls to set exchanges in their
    documentation.  I do not understand how this works.  My previous code just
    build two exchanges one on each of the different machines with the same
    name.  I think when I'm done, I'll just have a more complex version of what
    I had before.
    
    Spit balling a strategy:
      *Producer*:
      * [X] Put their blocking producer code into a thread
      * [X] Assign a timeout callback with this blocking producer before it
            starts; use a technique similar to what you did with your consumer
      * [X] Have the timeout callback wake up and look at a queue
      * [X] speed up the timeout callback mechanism if there are a lot of items
            in the queue, if there aren't then leave it at its baseline tempo
      * [X] To call the callback mechanism that sends the message using the func
            tools partial technique to force your message into that callback
            method call as an argument.
      * [X] Refactor the code, make sure logs make sense, update the docstrings,
            tidy.
      * [ ] Figure out what to do with the json serialization... try to get rid
            of it on both the producer and the consumer
      * [ ] Wrap up their basic code example and this extension into its own
            class.
      * [ ] Wrap this class within another class which provides the
            serialization and encryption features needed.
      * [ ] Since you have miros-rabbitmq open for surgery, change the encryption
            mechanism so that both the snoop and the mesh can set their own
            encryption key like the snoop can.
      * [ ] Write a url maker
      * [ ] Have a way to write a list of of url's to some producers
      * [ ] Write it up the docs for this library?
      
      *Consumer*:
      * [ ] Put their blocking consumer code into a thread
      * [ ] Assign a timeout callback with this blocking consumer before it
            starts; use a technique similar to what you did with your consumer.
  
  *Symptoms:*
  
  *Questions for Rabbit Disconnection Exception:*
    Can I understand their code? [good enough]
    Can I find a way to make the problem fail sooner. [moot]
    Can you simplify your test? [moot]
    What recently changed?

  *Assumptions:*

= Decide =
  *Idea/Hypotheses for Rabbit Disconnection Exception: >=5*
  * [ ] Reproduce old issue; time it [too long, moot]
  * [X] Get networking working
  * [X] Get user_name/password working
  * [X] Pass a string
  * [X] Understand their code in enough detail (obey, cooperate, diverge)
  * [X] Try to pass different strings using an API call into their example
  * [X] Put their blocking consumer code into a thread 
  *Chosen Idea/Hypothesis*
   
  *Plan to Expand-on-Idea/Disprove-Hypothesis*

= Act =

