*Rabbit Disconnection Exception*
= Observe =
  *What defines Success?*
  Place the pika team's asynchronous code example between miros and RabbitMq.
  
  But their code defies use with an API; for some reason they will not show a
  reasonable example.  Bend it to your will.
 
  *Immediate Goal:*
    Wrap their producer into its own thread.  Have it pend on a queue and
    dispatch information out to network using techniques discovered from reading
    the asyncio documentation.
  
  *Global problem?*
  My botnet was working, based on an old and unreliable way of using pika
  (RabbitMq docs).  
  
  But this code would fail after running for > 15 minutes.  The time-to-test was
  too long to troubleshoot that approach, so I decided to re-write everything to
  work from their stable example:
  
    One two bots (WSL):
      pika.exceptions.ConnectionClosed: (-1, "ConnectionResetError(104, 'Connection reset by peer')")
    
    The other two bots:
      pika.exceptions.ChannelClosed
      
  So, there needs to be a number of resets and other complications that were not
  talked about in the training examples.  To avoid this problem I will use their
  complicated pika-asyncronous example as a starting point, then wrap it with
  the functionality required for miros-rabbitmq
  
  *Immediate problem?*
    Their async code seems to be bit banger with callbacks.  You can start the
    service, but they only way you can get it to unhang is to use a timed
    callback method.  (but this is enough to work with)

  *Evidence that informs Assumptions:*
  
  Previous issues:
  
= Orient =
  *Information about the current context*
    The consumer will by on the pi
    The producer will be on the WLS
    The user/password will be the same as before
    
    The exchange is defined by the consumer, the producer's machine does not have the exchange
    The pi exchange: http://192.168.1.69:15672/#/exchanges
    The WLS exchange: http://127.0.0.1:15672/#/exchanges
    With PUBLISH_INTERVAL = 0.00000000000000000000001 it ran for 5 minutes with no issues
    
    There is some mention about RPC calls to set exchanges in their documentation.
    I do not understand how this works.  My previous code just build two exchanges
    one the different machines with the same name.  I think when I'm done, I'll
    have a complicated version of the same thing using their code.
    
    Spit balling a strategy:
      * Put their blocking producer code into a thread
      * Assign a timeout callback with this blocking producer before it starts;
        use a technique similar to what you did with the consumer
      * Have the timeout callback wake up and look at a queue
      * speed up the timeout callback mechanism if there are a lot of items in
        the queue, if there aren't then leave it at its baseline tempo
      * To call the callback mechanism that sends the message using the func
        tools partial technique to force your message into that callback method
        call as an argument.
      * Wrap up their basic code example and this extension into its own class
      * Wrap this class within another class which provides the serialization
        and encryption features needed.
      * Since you have pika open for surgery, change the encryption mechanism so
        that both the snoop and the mesh can set their own encryption key like
        the snoop can.
  
  *Symptoms:*
  
  *Questions for Rabbit Disconnection Exception:*
    Can I understand their code?
    Can I find a way to make the problem fail sooner. 
    Can you simplify your test?
    Do you have enough information?
    What recently changed?

  *Assumptions:*

= Decide =
  *Idea/Hypotheses for Rabbit Disconnection Exception: >=5*
  * [ ] Reproduce old issue; time it [too long]
  * [X] Get networking working
  * [X] Get user_name/password working
  * [X] Pass a string
  * [X] Understand their code in enough detail (obey, cooperate, diverge)
  * [ ] Try to pass different strings using an API call into their example
  * [ ] Refactor their code to work with your botnet (generate new work list)
  * [ ] Pound the exchange and see if it fails [it worked]
  * [ ] Run it to failure and see what happens
  
  *Chosen Idea/Hypothesis*
    Try to pass different strings using an API call into their example
    * They have an event loop with no way of passing in messages 
    * Move their event loop into a task, and have it feed off of a queue
    * 
    
  *Plan to Expand-on-Idea/Disprove-Hypothesis*

= Act =

