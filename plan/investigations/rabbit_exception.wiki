*Rabbit Disconnection Exception*

= Observe =
  *What defines Success?*
  
  We need a way to manage the IP addresses and AMQP_URLS for the miros-rabbitmq
  library that is better and faster than the current technique.  The current
  technique examines the network information for the computer, finds the
  broadcast address and pings this address to fill the arp table
  (Linux/Windows).  It then accesses this ARP table to build amqp urls with a
  single timeout try and hits all of the addresses in the local network.  This
  could be a bad idea for a large network.  It disqualifies any address that
  times out; but this time out process is very fragile and slow.
  
  I would like to build on this technique, I would like to cache these results
  and have a timeout which when expired would run through the process again, but
  up until that point would just use the cache.  This would speed up the startup
  time.
  
  In the case that the device is discovered by a dark client, it should add this
  dark client to it's list even if it didn't know about it before, so there
  should be an auto-discovery process.  (Security is managed through the
  encryption keys not through the autodiscovery process)
  
  I would also like to have the ability to skip the process entirely
  using a list of known ampq_urls.  This configuration technique should be
  simple to use. 
  
  I would like the miros-rabbitmq networks to share their caches.
  
  This Design should:
    * Time-out the cache if too old
    * Skip the discovery process if cache relevant 
    * If cache too old, discover network
    * Write network discovery to cache
    * Begin
  
  After delay:
    * Update cache with ip/amqp_url from dark nodes
    * Turn messages from dark nodes into new producers
    * Transmit cache to other nodes in network
    * If cache item not responding, remove it from the cache
  
  Upon receiving alien cache:
    * Test IP addresses with longer time out
    * If IP does respond update the cache
    * Treat new IP address like a dark node, see above
  
  Constraints:
    * Cache file access should only happen in one thread
    
  *Immediate Goal*
    Wrap your head around the requirements; write your ideas down.
    
  *Problem*
    The requirements are not understood yet.
    
  *Code Cache*
  To extract an IP from a URL using the host file:
  import socket
  socket.gethostbyname('google.com')    #=> 216.58.193.78
  socket.gethostbyname('216.58.193.78') #=> 216.58.193.78
  
  *Evidence that informs Assumptions:*
  
= Orient/Homework/Empathy =
  *Information about the current context*
    The pi exchange: http://192.168.1.69:15672/#/exchanges
    The WLS exchange: http://127.0.0.1:15672/#/exchanges
    
   *Feature Visions*: 
      *Producer*:
      *Consumer*:
      *Scout*
      *Mesh*
      *Snoop*:
      * [ ] Add coloring from different machines
      * [ ] Add spy filtering [doesn't make sense]
      *Integration*
  
  *History*
    I built a botnet to describe multiunit statechart patterns.
    
    My botnet was working, based on an old and unreliable way of using pika
    (from RabbitMq docs).  
    
    But this code would fail after running for > 15 minutes.  The time-to-test
    was too long to troubleshoot comfortably (this is volunteer work), so I
    decided to re-write everything based on the pika project's stable example.
    Errors seen in my previous version:
    
      One two bots (WSL):
        pika.exceptions.ConnectionClosed: (-1, "ConnectionResetError(104, 'Connection reset by peer')")
      
      The other two bots:
        pika.exceptions.ChannelClosed
        
    So, there needs to be a number of resets and other complications that were
    not talked about in the RabbitMq-pika training examples. (My old code is
    broken and the testing cycle takes > 15 minutes)
    
    To avoid this problem again I will use the pika documentation's complicated
    pika-asyncronous example as a starting point, then wrap it with the
    functionality required for miros-rabbitmq.  (Once again, you can't trust the
    DOM.)
    
    The miros-rabbitmq package was built and tested and documented.  The
    encryption scheme was updated using modern techniques; but the network
    discovery process and network definition design is still redimentary.
  
  *Symptoms:*
  
  *Questions for Rabbit Disconnection Exception:*
    Have you written code like this is a previous design.
    What don't I know that I need to know?
    Can you break the problem down into logical parts.
    
    Am I going to review this process when I have finished it?
    Can I Improve this process?
    Can I make better decisions this time?

  *Assumptions:*

= Decide =
  *Idea/Hypotheses for Rabbit Disconnection Exception: >=5*
  * [X] Add caching and cache time out for scout process
  * [X] Select cache file format
  * [X] Select cache file structure (simple please)
  * [X] Have ability to destroy cache
  * [X] Have ability to expire cache
  * [X] Move the cache code into a sensible location of the network.py file
  * [ ] Ensure you have the ability to get the IP address out of an AMQP URL
  * [ ] 
  
  *Chosen Idea/Hypothesis*
   
  *Plan to Expand-on-Idea/Disprove-Hypothesis*

= Act =

