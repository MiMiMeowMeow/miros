
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Mongol Horse Archer &#8212; miros 2.0 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Recipes" href="recipes.html" />
    <link rel="prev" title="Spy and Trace Across a Network" href="networked_instrumentation.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <blockquote id="i-mongol-example-mongol-horsemen">
<div><p><em>It ain’t what you don’t know that gets you into trouble.  It’s what you know
for sure that just ain’t so.</em></p>
<p class="attribution">&mdash;Mark Twain (fake quote)</p>
</div></blockquote>
<div class="section" id="mongol-horse-archer">
<h1>Mongol Horse Archer<a class="headerlink" href="#mongol-horse-archer" title="Permalink to this headline">¶</a></h1>
<p>In this example I will demonstrate how to write a type of tactical botnet.  I
will base it on something from history, the Mongol Horsemen.</p>
<img alt="_images/archer.jpg" class="align-center" src="_images/archer.jpg" />
<p>The example will demonstrate how to design <a class="reference external" href="https://en.wikipedia.org/wiki/Self-organization">emergent order</a> using multiple nodes across
a network, which have limited information about one another.  Each node will
have the ability to link up with another node and act in unison and then unlink
and act under their own initiative.  The overall unit tactic will continue to
work even if only one node remains.</p>
<p><strong>Example Background:</strong></p>
<ul class="simple">
<li><a class="reference internal" href="#i-mongol-example-historical-context"><span class="std std-ref">Historical Context</span></a></li>
<li><a class="reference internal" href="#i-mongol-example-distributed-officers"><span class="std std-ref">Deceit in Detail</span></a></li>
<li><a class="reference internal" href="#i-mongol-example-modelling-the-mongol-mind"><span class="std std-ref">Modelling the Mongol Mind</span></a></li>
</ul>
<p><strong>Example Software:</strong></p>
<ul class="simple">
<li><a class="reference internal" href="#i-mongol-example-technical-oveview"><span class="std std-ref">Technical Overview</span></a></li>
<li><a class="reference internal" href="#i-mongol-example-designing-the-mongol-in-its-tactic"><span class="std std-ref">Designing the Mongol in its Tactic</span></a></li>
<li><a class="reference internal" href="#i-mongol-example-encrypted-communications"><span class="std std-ref">Encrypted Commnications</span></a></li>
<li><a class="reference internal" href="#i-mongol-example-instrumenting-to-debug-the-botnet"><span class="std std-ref">Instrumenting to Debug a Horse Archer</span></a></li>
<li><a class="reference internal" href="#i-mongol-example-implementing-the-mongol-in-miros"><span class="std std-ref">Implementing the Mogol in miros</span></a></li>
</ul>
<div class="section" id="some-historical-context-for-the-example">
<span id="i-mongol-example-historical-context"></span><h2>Some Historical Context For the Example<a class="headerlink" href="#some-historical-context-for-the-example" title="Permalink to this headline">¶</a></h2>
<p>Military officers are faced with the paradox of leadership.</p>
<p>As a leader they collect information about their army and as much intelligence
about their enemy as they can access.  From this information they render a plan
of how to harm their enemy as much as possible while limiting losses to their
own force.</p>
<p>An officer must exert their plan onto an army of men who would rather be at
home working their fields and feeding their families.  When an officer exerts
their power over a soldier they reduce that soldier’s ability to think for
themselves.  But each battling soldier consumes tremendous amounts of
information; far too much to send up the chain of command.  If they could act
upon it independently, it could be to the great advantage of their army.  This
is the paradox of leadership, when a leader exerts too much control over their
subordinates they limit the effective intelligence of the group to their <em>own
mental ability</em> and the <em>limited information</em> they are receiving.</p>
<p>The chain of command is like an extremely slow nervous system.  Limited and
bottle-necked by the cognitive load and biases of each officer as they transmit
orders to their soldiers and the results of those orders back up to their own
ranking officer.</p>
<p>But without officers providing decisions in battle, the group would breakdown
into a set of unorganized individuals who at best, would default to their
training and at the worst would run from the enemy exposing themselves to
slaughter.  Group cohesion is the key.</p>
<p>In war their are hard points and weak points to armies.  Ideally, you would
attack your opponents weak point with your hard point.  An example of this is a
flanking maneuver.  If you can hit your enemy at the side (flank), rather than
at their front, you would minimize your losses while maximizing theirs.</p>
<p>But the chain of command itself, is a weak point in an army.  If you could kill
the officer’s of your opposing force, you would turn the army into a group of
scared men all acting alone.  A micromanaging general who is exerting absolute
control can be attacked directly with confusion and mental over-taxation.  Such
a general becomes a weak point because of the paradox of leadership.  As their
mental abilities are diminished by confusion their army acts dumber, making ever
worse collective decisions.</p>
<p>In the 13th Century, western armies typically organized their officers in
hierarchical structures, using command and control architectures.  The officers
would be on the front line, mounted on horse back, wearing heavy armor, easy to
identify.</p>
<p>The Mongol forces were organized differently, each horse archer could act as a
local officer to control the over all efforts of their local unit.  Each unit
was made up of no more than ten horse archers.  The cognitive load required to
control the whole system was limited, because each unit could act independently
from their whole.</p>
<p>There was still a hierarchy of leadership in the Mongol army with different
ranking officers controlling the actions of the groups of units under their
command; but orders where issued as intentions, rather than a specific set of
individual instructions.  Today we call this, “commander’s intent”.  If such
orders are used, the military force under their command becomes smarter than the
officer issuing them.  Each officer at each level can innovate and react to
their local battles as they unfold.  Officer-ship itself is pushed down into the
individual soldiers.</p>
<p>The Mongol tactics and strategy were intended to harm the state of mind of the
opposing military commander.  They would not stay put, they would not act in a
way that could be fathomed by theory or previous experience.  They would put
their opponents into constant conundrums, if their enemy closed ranks the
Mongols would fire arrows on the mass of men, if they spread out, the Mongol
could attack and pick off the individuals.</p>
<p>Any opposing micro-manager would quickly become overwhelmed, leaving their
forces lobotomized; breaking down cohesion.</p>
<p>So confusion was the great weapon of the Mongols and it was blasted directly at the
minds of the military commanders controlling the opposing force.  When a Mongol
army came upon a larger army controlled using traditional-command-and-control
cognition, it was a simple matter to destroy them at their leisure – since the
opposing army lacked to mobility to catch or surround the mongols.</p>
<p>The Mongols would engage, feign a retreat, then move into more favorable
terrain.  The opposing force would be lead away from their strong point,
exposing a supply line and become small enough that the Mongols could attack
them en masse with numerical superiority.</p>
<p>This tactic is called “Defeat in Detail”.</p>
</div>
<div class="section" id="deceit-in-detail">
<span id="i-mongol-example-distributed-officers"></span><h2>Deceit in Detail<a class="headerlink" href="#deceit-in-detail" title="Permalink to this headline">¶</a></h2>
<p>Now let’s talk about a specific “Defeat in Detail” set of tactics used by an
individual unit of Mongol horse archers.</p>
<p>Their commander’s intent was for them to lure the enemy away from its protecting
mass and kill as many officer’s as possible.</p>
<p>Each horse archer started a fight with 60 arrow’s and a scimitar.  They wanted
to damage the enemy with the arrows from a distance so that they could avoid
risk.  They would only pull their scimitar while close to their prey.  But the
point of the scimitar wasn’t to kill or maim their enemy, but to protect
themselves while they got close enough to present a lie.</p>
<p>In close quarters the Mongol would pretend that they were scared.  They would
act as if their unit’s will was broken when it wasn’t.  This behavior would have
been especially alluring to any opposing military officer’s who wanted to prove
their valor.  They would have been more willing to see this fake weakness as a
truth; enraged and frustrated with their own inability to take action, they
would be inclined to take the bait.</p>
<p>The Mongol units had to attack as a unit and retreat as a unit.  To do otherwise
would have had them executed by their own senior officers for lack of cohesion.</p>
<p>But the retreat requirement of this cohesion-directive was often broken by the
fog of war. They couldn’t always know if another horse archer had been killed
and to wait around and get killed themselves would have been stupid; so a
compromise was reached.  When a horse archer saw that their enemy was
re-organized enough to put up real resistance, or better yet,  they had
successfully lured an officer, they could issue a retreat war cry and all other
horse archers within earshot would follow them to a predetermined marshal point.</p>
<p>While retreating, the horse archers would turn and use their last arrows on the
enemies chasing them; placing the highest priority on officers.</p>
<p>It is possible that modern Western military theory has still not caught up to
medieval Mongol thinking.  The tactic name, “defeat in detail” might have been
called “deceit in detail” had it been written down by a 13th century Mongol,
instead of a despotic Frenchman.</p>
</div>
<div class="section" id="modelling-the-mongol-mind">
<span id="i-mongol-example-modelling-the-mongol-mind"></span><h2>Modelling the Mongol Mind<a class="headerlink" href="#modelling-the-mongol-mind" title="Permalink to this headline">¶</a></h2>
<p>A group of Mongol horse archers needed to protect their mental flanks while
doing the most to harm their opponents.  The key to this is to make the group
tactic simple from the inside and bafflingly complex from the outside.</p>
<p>Each soldier needed independent thought and action but in a moment to be able to
snap back into a collective dance with the rest of their unit.  The calls
between the members of a unit needed to be encrypted, simple and loud.</p>
<p>The amount of memory needed to track their brethren also needed to be limited.
Unlike the general trying to remember and track everything all at once, our
distributed officer only needed to remember a few crucial things.</p>
<p>To make things mentally easier, the Mongol soldier relied on the idea of
sameness.  The ergodic mirror metaphor is useful here.  If you were surrounded
by an ergodic mirror, anywhere you turn you would be looking into your own eyes.
So the Mongol horse archers where ergodic; they were surrounded by themselves.
Every member of their unit would act as they would, so there was no concern or
doubt about what to do.</p>
<p>The tactics used by a unit of horse archers needed to work even if some of its
members were killed.  The hologram provides another useful metaphor.  A
holographic sheet is a two dimensional thing, yet as its parts work together it
produces something in the third dimension.  If you scratch the holographic
sheet, the three dimensional image remains, only slightly fuzzier than it was
before.  To be effective the Mongol tactics needed to have this same property.
As a unit they express complexity beyond the sum of their parts and this
complexity would not break down with losses, but only lose its fidelity.</p>
<p>Let’s weave these metaphors into the specifics of battle.  To begin with a
Mongol unit would meet, fill their quivers with arrows and decide where they
would meet again after their first encounter.  This next place, call it a
marshal point, would be on ground which would give them some sort of advantage
and access to more ammunition.</p>
<p>They would wait for an advance-war-cry.  Any member of their unit could issue
this call and all members would immediately advance.</p>
<p>At a certain distance from the enemy the horse archers would have their horses
follow each other to form a circle.  The closest horse archer to the enemy front
lines would shoot an arrow, then reload as their horse took them around the
circle again.  This would create a kind of sustained machine gun effect on their
opponent’s mass; causing them to loosen their ranks as to avoid the constant
barrage of arrows.</p>
<p>The next stage of battle would have the horse archers get close enough to their
enemy to skirmish.  While skirmishing a horse archer would aim their arrows
directly at individual opponents.  To begin a skirmish any of the horse archers
could issue a skirmish war cry and all other units would follow, breaking away
from their circle to move close into the now disordered front of their enemy.
At some point one of the horse archers would become low on ammunition; then they
would begin the most dangerous and effective movement in their ‘deceit in
detail’ tactic, they would pull their scimitar; saving the last of their arrows
for their luring retreat.</p>
<p>While swinging their scimitar they would do exactly the opposite of what you
would expect a terrible horse archer to do.  They would appear scared and
confused; disoriented and craven.  It is not easy to charge into the heart of
your enemy only to put on a play for them; but this deceit was necessary to lure
their enemy into <em>real</em> danger.</p>
<p>So as a horse archer was fighting, they would have to remember enough about their
unit to know if they were the last to pull their scimitar.  If they were, it
meant that as a unit they were low on ammunition and they were ready for a their
next collective action.</p>
<p>This would mean that a horse archer would have to call out when they were
pulling their scimitar; and each other horse archer would have to track this
information.  But if a horse archer was killed; they wouldn’t be able to call
out; so there had to be another way for the unit to communicate to itself that
it was time to go.  So any horse archer could issue a retreat war cry.  They
could do this when they had successfully lured an officer are when enough time
had passed that the enemy was becoming sufficiently reorganized to actually put
up real opposition.</p>
<p>The retreat war cry would occur when the last horse archer pulled his
scimitar, or when an officer was lured or when enough time had passed for the
enemy to re-organize.</p>
<p>A retreating horse archer was extremely dangerous; since they would pretend to
be slow when they were actually fast.  The closer you got to them, the easier
you would make their shot on you.  Your advance would not be protected by a
flanking soldier; but there would be another horse archer their also retreating
with his brethren.  They were especially dangerous to officers, since an officer
would often be on horse back to increase their mobility and express their rank.
The speed of the chasing officer would pull him away from his protecting mass;
leaving him alone and flanked by his enemies, his helmet blinding his peripheral
vision.  He had no real chance of catching his prey; all of his training and
ideas about the world working against him.</p>
<p>From the outside the mongols would appear like a angry swarm of wasps;
incomprehensible, always out of reach.  Any engagement with them reducing the
leadership and cohesion within your own force.</p>
<p>But if you were an individual horseman, you would only have to follow a few
simple rules.  Advance if you heard an Advance war cry.  Create a circle when
close enough to the enemy.  Skirmish when you heard a Skirmish war cry.  Track
your unit’s Retreat Ready War cries; so you can know if it is up to you to issue
the Retreat.  When you heard a Retreat War cry retreat and attack any lured
enemy’s flank.</p>
<p>As an individual horseman, you could issue your own commands to your group.  You
could give an Advance War Cry, to start the circle.  When you were low enough on
arrows you could make the Skirmish war cry and your brethren would close the
distance to the enemy with you.  If your ammunition was running low, you would
issue the Ammunition Low war cry and the other members of your unit would know
you are ready to go.  If you had successfully lured an officer, you could issue
the Retreat war cry and leave knowing that your brethren would follow and flank
the officer chasing you.</p>
<p>Most of your concentration would be used to make your shots, or to put on the
deceitful-play while close enough to the enemy.  The only exception to this
being your need to track who in your unit was ready to go.</p>
<p>If you were the last horseman, the rules would still apply:  You would advance;
you would circle and shoot; you would skirmish and lure and retreat-to-fire when
followed.</p>
<img alt="_images/backwards.jpg" class="align-center" src="_images/backwards.jpg" />
<p>Now that we have an understanding of what we are trying to model, let’s build it
in software using miros.</p>
</div>
<div class="section" id="technical-overview">
<span id="i-mongol-example-technical-oveview"></span><h2>Technical Overview<a class="headerlink" href="#technical-overview" title="Permalink to this headline">¶</a></h2>
<p>To build the horse archer botnet we need at least two different computers.  I’ll
be using a windows machine and a raspberry pi.</p>
<p>First, we’ll design a set of statecharts that will model an individual horse
archer and it’s understanding of it’s brethren.</p>
<p>Any communication between our horse archer bots will be encrypted, since we
don’t want our enemy to learn about what we are doing.</p>
<p>We will adjust how our instrumentation works; we will make it so that it can
stream its output to any computer of our choosing.  We will do this so we can
debug our entire botnet from one location.</p>
<p>Finally We’ll write the software; run it on two or more computers and demonstrate
that it is working.</p>
<p>Here are the steps:</p>
<ul class="simple">
<li><a class="reference internal" href="#i-mongol-example-designing-the-mongol-in-its-tactic"><span class="std std-ref">Designing the Mongol in its Tactic</span></a></li>
<li><a class="reference internal" href="#i-mongol-example-encrypted-communications"><span class="std std-ref">Encrypted Commnications</span></a></li>
<li><a class="reference internal" href="#i-mongol-example-instrumenting-to-debug-the-botnet"><span class="std std-ref">Instrumenting to Debug the Mongol Botnet</span></a></li>
<li><a class="reference internal" href="#i-mongol-example-implementing-the-mongol-in-miros"><span class="std std-ref">Implementing the Mogol in miros</span></a></li>
</ul>
</div>
<div class="section" id="designing-the-mongol-in-its-tactic">
<span id="i-mongol-example-designing-the-mongol-in-its-tactic"></span><h2>Designing the Mongol in its Tactic<a class="headerlink" href="#designing-the-mongol-in-its-tactic" title="Permalink to this headline">¶</a></h2>
<p>We already understand the tactic, so I’ll draw and describe how I think it might
work in an HSM several times over; adding complexity and technical improvements
with each iteration.  When we have a design that can sufficiently sketch out our
bot net I’ll move to the next technical step.</p>
<p>While working through the example we will introduce different events that cause
changes in the horse archer’s behavior.</p>
<p>When an event is a war cry, who exactly is yelling it out?  Any war cry can come
from one of two places.  It can come from the horse archer himself, or a senior
officer.  We do this so that the unit tactic can be autonomous yet flexible
enough to receive outside direction.</p>
<p>Let’s think about a single horse archer and the actions he would take.  He would
meet up with his brethren (marshal), then they would determine where they would like
to meet after their first maneuver, then they would fill their quivers with
arrows.</p>
<p>So, I have to first figure out what to call the outer state.  For now I’ll call it,
Deceit_in_Detail_Tactic (marshaled), because I want to express that the horse
archers are meeting and that this is one tactic of many that they could choose from.</p>
<div align="center" class="align-center"><img alt="_images/ergotic_mongol_11.svg" src="_images/ergotic_mongol_11.svg" /></div>
<p><a class="reference external" href="https://github.com/aleph2c/miros/blob/master/doc/_static/ergotic_mongol_11.pgn">ergotic_mongol_11</a></p>
<p>Immediately after filling their arrows, they attack.  This may not be
historically accurate, but let’s have our botnet just attack right away.</p>
<p>Once the horse archers advance close enough to the mass of their enemy, they
would circle and fire.  How do we express this in software?  If we were building
a botnet to fight the North Koreans or a malevolent AI or something, we could
have each node in our botnet read a transducer or take a reading.  For now we
will fake out this information with a
<a class="reference internal" href="recipes.html#recipes-create-a-one-shot-state"><span class="std std-ref">one-shot</span></a> so that we can frame in our
design.  Three seconds after advancing they will issue the
Close_Enough_For_Circle event.</p>
<p>So our horse archers circle and fire; creating an intangible rain of arrows down
upon the enemy’s front line. So far so good.  To save themselves, the enemy
loosens their ranks allowing enough space and safety for our horse archers to
charge in for their next play.</p>
<p>Notice that the Circle and Fire state is within the Advance state.  Why do this?
I did this in case an individual horse archer decided that the enemies front was
sufficiently disorganized enough not to waste arrows on an imprecise
bombardment; To skip the circle and fire step and just advance into a skirmish.
To do this, they would issue a Skirmish_War_Cry and charge into the enemy’s
disorganized front to make individual attacks.</p>
<div align="center" class="align-center"><img alt="_images/ergotic_mongol_12.svg" src="_images/ergotic_mongol_12.svg" /></div>
<p><a class="reference external" href="https://github.com/aleph2c/miros/blob/master/doc/_static/ergotic_mongol_12.pgn">ergotic_mongol_12</a></p>
<p>Upon making the Skirmish_War_Cry are horse archer charges into close enough
range to make individual attacks with their arrows.  This type of fighting is
called a skirmish to show that we do not want them to stick around.</p>
<p>Our war bot would have some client code connected to the entry condition of the
skirmish state.  It might be the initialization of a specific targeting and
attack control system, whatever it is it would have to issue the Ammunition_Low
event when it was done firing upon specific targets.  This Ammunition_Low event
would be caught by the skirmish state as a <a class="reference internal" href="patterns.html#patterns-ultimate-hook"><span class="std std-ref">hook</span></a>.
This hook would in turn, trigger a Retreat_Ready_War_Cry event.</p>
<p>I could have just used a single Ammunition_Low event to cause the transition
from the Skirmish state into the “Waiting To Lure” state.  But, I often use two
distinct events like this to make the debugging and reflection processes easier
on myself, so that I can debug a statechart faster than I could with only one
event that expresses two different semantic meanings.  (This will also give our
design more flexibility, which we will see later in this example).</p>
<p>After a horse archer issues the Retreat_Ready_War_Cry they enter the “Waiting to
Lure” state.  He would expertly attach his bow to his mount and pull his
scimitar, then he would do something really brave.  He draw the attention of an
enemy officer and somehow convince him that he was scared and incompetent, that
his unit’s will was broken.  While in the waiting to lure state, he would act
like a father who is being chased by his children.  He would pretend that they
could actually catch him if they only just tried a little bit harder.</p>
<p>The western Knight would be spoiling for a fight, feeling enraged, yet
incompetent, he would want to do something other than watch his footmen die.  He
might look down at his massive warhorse and compare it to the strange little
ponies these horse archers are riding.</p>
<img alt="_images/horsearcher.jpg" class="align-center" src="_images/horsearcher.jpg" />
<p>What he doesn’t know is that he is the quarry.  They are on a hunting trip; not
every arrow carries the same value; the whole point of their attack was to find
him.  They have something to give him.</p>
<p>The Knight see’s his chance and attacks!</p>
<p>Once again we find ourselves needing real input from the world.   This is where
our bot would need another transducer or reading to determine if the officer had
been lured.  For now we will fake out the reading with another one-shot, so that
we can frame in the design.  To make things interesting we will pick a random
integer between 3 and 12 and then count down in seconds before we trigger our
fake Officer_Lured event.</p>
<p>The horse archer has been paying careful attention to the Knight even though he
has been pretending not to see him.  When he sees him begin his attack, he
issues the Officer_Lured event.</p>
<p>The Officer_Lured event is caught by a hook, which triggers the Retreat_War_Cry.
The Retreat_Ready_War_Cry causes an exit transition from the “Waiting to Lure”
state.  This will have the horse archer put away his scimitar and arm his bow
with an arrow.</p>
<div align="center" class="align-center"><img alt="_images/ergotic_mongol_13.svg" src="_images/ergotic_mongol_13.svg" /></div>
<p><a class="reference external" href="https://github.com/aleph2c/miros/blob/master/doc/_static/ergotic_mongol_13.pgn">ergotic_mongol_13</a></p>
<p>The Retreat_War_Cry causes the horse to enter the “Feigned Retreat” state.  In
this state, a different control system would come into play.  The horse archer
would let the Knight close the distance to him, so that he can comfortably make
his shot.</p>
<p>He might even veer and dodge to place bodies and soldiers between him and the
charging Knight, or lure him closer toward other horse archers who could flank
the knight; taking advantage of how his helmet has cut off his peripheral
vision.  It doesn’t really matter; once the knight attacks, stupidly charging
into a group of organized horse archers with unprotected flanks, he is doomed.</p>
<p>What to do next?  The unit goal has been achieved, yet they still have arrows.
So they leave them in any other pursuing soldiers, then ride full gallop back to
the marshal point.</p>
<div align="center" class="align-center"><img alt="_images/ergotic_mongol_14.svg" src="_images/ergotic_mongol_14.svg" /></div>
<p>The final stage of our tactic would have the horse archers meet at their marshal
point.  Their they would decide upon where to meet again after their next
attack.  Load their horses with arrows, tell some jokes and field wrap their
wounds.  Drink and water their horses and mentally prepare themselves for the
next advance.</p>
<p>The requirement for group cohesion still applies.  Any horse archer would be
limited on the battle field if he had to advance with an empty quiver; so every
horse archer would want to wait for the last horse archer to finish reloading
before advancing.</p>
<p>Therefore like the “Waiting to Lure” state, there must be a “Waiting to Advance”
state.  In this first pass at a design, we setup a one shot that will trigger
the READY event after three seconds.</p>
<p>In the “Waiting to Advance” state we place a randomized one-shot that will
trigger the Advance_War_Cry at some time between 3 and 12 seconds.</p>
<p>But this overall tactic, as it is currently designed is completely fragile.
What happens if a horse archer is issued an Advance_War_Cry while in the
“Marshal” state?  Well, he would just sit there.  What would happen if a
Skirmish_War_Cry was issued while the horse archer was in the “Feigned Retreat”
state?  They would ignore the command.  This is not flexible.</p>
<p>There will be situations where a senior officer issues an Advance_War_Cry when
the horse archer is not ready; no matter, it is time to attack, even without
arrows.  Group cohesion is of paramount importance to the Mongols.</p>
<p>So, as a map it is easy to see what is going on, but it tells a very specific
and inflexible story.  With a few light adjustments we could make the horse
archer much more seasoned and responsive in the face of unexpected events.</p>
<p>For instance we could make the Advance_War_Cry cause an advance on the enemy
while the horse archer is in any of it’s maneuvers.  Suppose a horse archer is
in the “Feigned Retreat” stage and a senior officer sees some sort of global
opportunity and bangs on a war drum, issuing a global Advance_War_Cry.  Our
horse archer would turn around and advance.</p>
<p>In this way the control at a higher leadership level of the mongol army could
reach into this unit, tweak its behavior, then let it run autonomously again.</p>
<p>Let’s improve the design:</p>
<div align="center" class="align-center"><img alt="_images/ergotic_mongol_2.svg" src="_images/ergotic_mongol_2.svg" /></div>
<p>As a statechart designer, you might look at the Advance_War_Cry event connecting
the outer state to the advance state and become confused.  Where does this
Advance_War_Cry come from?  Oh, there it is, in the “Waiting to Advance” state.</p>
<p>I have seen junior developers destroy designs by adjusting arrows to make the
“story easier to read” off of the map.  It is tempting to put the arrow source
back to the “Waiting to Advance” state so that the map makes immediate sense
upon looking at it. But think about what this has done to our design.  When an
arrow is connected from the outer state, to the “Advance” state, it is shorthand
for connecting <em>all of the states</em> to the “Advance” state with an
Advance_War_Cry arrow.  When the junior developer mistakenly adjusts the tactic
to make the map “make more sense”, they would break 7 different behavioral
pathways in this design; causing our horse archer unit to lose cohesion and thereby
guarantee its execution by a senior officer.  Statecharts are
extremely powerful at packing tactical complexity onto a map; so you really have
to be careful moving the arrows around.</p>
<p>Now let’s adjust the Skirmish_War_Cry and the Retreat_Ready_War_Cry from the
outer state to their respective states.  We just added 14 different behavioral
paths.</p>
<p>Suppose that in the future, a new developer decides to adjust the deceit-in-detail
tactic by adding another state within it.  If they do not change how our
war-cry event arrows are attached, they will automatically get the behavior of
the old tactic without knowing that they did.  Statecharts are robust against
state additions made by future programmers.  So statecharts can quickly act like
a culture, they become smarter than the individual programming them.</p>
<p>Notice that the Out_Of_Arrows event was not globalized.  We do not want our
horse archer to just leave when he’s out of arrows.  Furthermore, because of our
adjustments to globalize the Advance_War_Cry, Skirmish_War_Cry and the
Retreat_War_Cry we have to ensure we don’t accidentally leave our horse archer
stranded in a state when he is out of arrows.</p>
<p>So what happens if an empty horse archer is asked to advance?  Well, he
uselessly circles and then will issue a Skirmish_War_Cry.  Good, he can escape
the “Advance” state.</p>
<p>Notice that some code was added to the entry state of the “Skirmish” state.  Now
if a horse archer has less than 10 arrows, or no arrows, he will end up in the
“Waiting to Lure” state.  This is good, he is no longer just uselessly riding
around because he can start to bait knights and he can escape the “Skirmish”
state event if he doesn’t have arrows.</p>
<p>Likewise, entry code was added to the “Feigned Retreat” state.  When he enters
this state with no arrows, he will just ride back to the marshal point.</p>
<p>Now that we have a decent adumbration of a horse archer acting alone, let’s add
control so the horse archers can react to the behavior of other horse archers.</p>
<p>A horse archer is a distributed officer.  This means that any horse archer can
issue commands to, or obey commands from, any other horse archer in his unit.
For this unit tactic, there are two types of commands.  There is a “Let’s do
this thing right now!” and a “Track that I am ready in your head!” kind of
command.</p>
<p>To see what I mean consider the Advance_War_Cry.  That is a “Let’s do this thing
right now” command.  All horse archers will immediately advance and circle if
they issued the command themselves or if they hear it come from another horse
archer or a senior officer.  In the deceit in detail there are three different
war cries that have this type of characteristic: Advance_War_Cry,
Skirmish_War_Cry and Retreat_War_Cry.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The “Let’s do this thing right now!” variety of signaling between different
statechart can be generalized into the “multi-chart race pattern”, since each
of the statecharts can be thought of racing each other to be the first to give
the command to another chart.  If given all of the statecharts will race to
the state indicated on their map.</p>
</div>
<div align="center" class="align-center"><img alt="_images/ergotic_mongol_31.svg" src="_images/ergotic_mongol_31.svg" /></div>
<p>Let’s turn each of these commands into three distinct events so that we can tell
if it was issued by a senior officer, the horse archer themselves or another
horse archer.  By doing this our statechart will be easier to debug, it’s
instrumentation will be clear and the sequence tool will tell a better story.</p>
<p>We construct three new events, Senior_Advance_War_Cry, Senior_Skirmish_War_Cry
and Senior_Retreat_War_Cry.  Imagine that these commands can be issued at a high
vantage point by war drums near the back of the Mongol horde.</p>
<p>When a horse archer hears a command from a senior officer, they will give the
cry themselves and then perform the action.  We implement this using the
reminder pattern.  A hook is placed at the outer state for these commands; and
it re-issues a new event as a response.</p>
<p>When a horse archer calls out, it can be heard by other horse archers through a
mechanism we haven’t programmed yet, but that doesn’t mean we can’t name these new
events: Other_Advance_War_Cry, Other_Skirmish_War_Cry and Other_Retreat_War_Cry.</p>
<p>There will be situations where a horse archer wants to ignore a command coming
from a senior officer or from his brethren.  This is when he is already engaged
in a complicated maneuver that would be initiated by that command.  For instance
while the horse archer is baiting a knight in the “Waiting to Lure” state, they
would ignore the Senior_Skirmish_War_Cry and the Other_Skirmish_War_Cry since
they are already engaged in that activity.</p>
<p>Likewise, a horse archer would ignore any order to advance, coming from someone
else, if they are already advancing or engaged in the circle and fire maneuver.</p>
<div align="center" class="align-center"><img alt="_images/ergotic_mongol_32.svg" src="_images/ergotic_mongol_32.svg" /></div>
<p>Battle is a noisy affair.  There is a good chance that one horse archer might
not hear a war cry issued by another one far away from him (due to network
issues); so anytime a horse archer hears a war cry coming from another horse
archer, they yell out the command again so as to re-transmit it to any other unit
member within earshot.</p>
<p>Notice also that I moved the Officer_Lured hook from the “Waiting to Lure” state
into the “Skirmish” state.  This will give us the same behavior as before, with
the option of short circuiting the dangerous “Waiting to Lure” state in the case
that a Knight stupidly charges at the moment the Mongols start to Skirmish.</p>
<p>Our design so far, has encompassed the “Let’s do this thing right now!” part of
it’s collaboration.  Senior officers can issue messages, any horse archer can
hear messages from other horse archers and the horse archer can yell out
messages to other horse archers.  When an action is taken by one Mongol, it will
be immediately taken by the others in its unit.  So, in a way they are racing
each other to get to the next state.  For this reason I call this a “multi-chart
race pattern”.</p>
<p>Now let’s talk about the “Track that I am ready in your head!” set of commands.
These types of commands are issued when the unit is waiting for the last of it’s
members to do something before they can all continue onto the next collective
behavior.  We have two such moments in this “deceit in detail” tactic.  The
first occurs when a horse archer puts away is bow and tries to lure a knight.
He yells his Retreat_Ready_War_Cry, hoping that all of the members in his unit
will hear him.  When the last horse archer issues the Retreat_Ready_War_Cry he
will know that it is up to him to issue the Retreat_War_Cry so his entire unit
can escape this dangerous luring maneuver.</p>
<p>The second “Track that I’m ready in your head!” command happens when the units
are marshaled.  It is up to the last horse archer to tell the others that he is
ready so they can get back into the fray.  He does this by issuing the
Advance_War_Cry.</p>
<p>So, a horse archer has to track what is happening with his brethren.  He has to
know what state they are in.  Thankfully he doesn’t have to know <em>precisely</em>
what they are doing but only a small subset of what they are doing.  For this
reason I call this unit empathy and it could be tracked by a second statechart.</p>
<p>Here is a first shot at it’s design:</p>
<div align="center" class="align-center"><img alt="_images/empathyfull.svg" src="_images/empathyfull.svg" /></div>
<p>A horse archer will have one of these statecharts for each member of his unit.
It is a simplification of how another horse archer is conducting themselves.</p>
<p>Another horse archer’s “Advance”, “Circle and Fire” and “Skirmish” states are
rendered down in the “Other Attacking” empathetic state.  The “Marshal” and
“Feigned Retreat” states are rendered down into the “Other Marshaling” state.
The “Waiting to Lure” and “Waiting to Advance” states are left intact.  There is
something new added to the empathy statechart; the “Other [is] Dead” state.</p>
<p>If you wait for a dead man, you will be waiting a long time – unless you are
waiting for a dead man on a battlefield, then you will not be waiting long.</p>
<p>It almost goes without saying that a horse archer will only wait for another
horse archer if he thinks he’s alive.</p>
<p>There really isn’t perfect knowledge in battle.  So, the idea that a horse archer
has about another horse archer will often be wrong, until that belief is updated
by more evidence and it snaps back to the truth.</p>
<p>But how would a horse archer come to the conclusion that someone else in their
unit is dead?  Well if that other horse archer is breaking the rules of their
collective tactic, it is safe to assume he is doing so because he has been killed.</p>
<p>We see this when a horse archer thinks that another member is attacking but
finds himself issuing a Retreat_War_Cry.  The other member should have been in
the waiting to lure state, but they weren’t, so he just assumes they are dead
and continues to fight.</p>
<p>Of course this will often be wrong.  If the first horse archer to enter the
“Waiting to Lure” state lures a knight right away; he would issue a
Retreat_War_Cry and with this design, he would think everyone else is dead.
This is OK, because he will immediately hear the other members of his unit yell
out; which will quickly change his beliefs back into a more truthful state of
empathy.</p>
<p>So here we are talking about a kind of belief lag.  The thing that the horse
archer needs to know is if the person is dead while they are waiting around.  If
they have incorrectly concluded their entire unit is dead while retreating,
there is plenty of time to fix this erroneous belief with the truth.  The next
wait state doesn’t happen until after they have finished their false retreat and
equipped their horse for another attack.  So, they can be wrong about things for
a while without any consequence to the over all group tactic.</p>
<p>A symmetrical logic applies to the “Other Marshaling” part of the design.</p>
<p>The important thing to notice here is that in many situations the group’s
cohesion will actually be broken by what happens to them in battle.</p>
<p>But what about the draconian requirement placed on this unit by it’s senior
officers, “maintain your group cohesion or we will kill every member in your
unit”.  If the Mongol horde adhered to this command with autistic compliance, all
the way up their leadership hierarchy, there would only be one horse archer left
and his name would be Genghis Khan.</p>
<img alt="_images/Genghis_Khan.jpg" class="align-center" src="_images/Genghis_Khan.jpg" />
<p>So the group cohesion requirement has to be some kind of hand waving thing.  “We
want you to follow each other around or re-synchronize in unusual situations, if
you don’t we will kill you.”</p>
<p>Basically the design has to be such that when cohesion is lost across the nodes
in our botnet that they snap back into the desired group dynamic when given the
opportunity to do so.</p>
<p>Here we are talking about attractors.  The idea was first introduced by Edward
Lorenz when he was studying chaotic systems.  His equations would never follow
the same path, but they would follow the same path-ish-ness:</p>
<img alt="_images/lorenz1.png" src="_images/lorenz1.png" />
<p>We aren’t going to delve into any mathematical rigor, but instead lean heavily
on our intuition and our design sensibilities.  A set of statecharts could be
explained using a stick in some mud in the 13th century.   This would be harder
to do with calculus, differential equations and linear algebra, so let’s stay
away from that.</p>
<p>Which brings us back to the idea of cognitive load.  We are expecting these
horse archers to remember a lot of things while in the heat of battle.  If I
were an officer explaining <em>this</em> empathy tactic, I would be complicit in
weakening the unit by filling their head with over complicated maps.</p>
<p>So let’s make things easier on them:</p>
<div align="center" class="align-center"><img alt="_images/empathypartial.svg" src="_images/empathypartial.svg" /></div>
<p>Now they are less precise in how they model the other members of their unit; yet
the same kind of states appear.  They know who is waiting, who is not waiting and
who is dead.</p>
<p>Let’s layer in a Mongol’s empathy into his tactical statechart:</p>
<div align="center" class="align-center"><img alt="_images/ergotic_mongol_41.svg" src="_images/ergotic_mongol_41.svg" /></div>
<p>The point of this design iteration is to add the two different unit-wait states.</p>
<p>If you were a horse archer, you would know the names and the voices of every
member of your unit.  Maybe you wouldn’t be able to do multiplication in your
head, or count cards, but you certainly would know what your brothers were doing
in battle.  It would be a basic skill, like riding your horse, like operating
your bow, like knowing where your arm is.</p>
<p>Our botnet is running on a computer, so tracking things in memory is trivial for
it.  Yet, we want to ensure the code is maintainable; legible.  So, we organize
our unit empathy into a data dictionary where the keys are just the IP addresses
of the other nodes.  The name of this collection would be called “others”.</p>
<p>The mental operation of tracking another horse archer in battle would involve
hearing his war cry, recognizing his voice and updating your notion of what he
is doing.</p>
<p>In our botnet, another’s war cry, is just an event with the “Other” as a prefix.
This event will carry with it a name and the node’s IP address as its payload.</p>
<p>So anytime we hear another make a war cry, we have to feed this information into
his empathy statechart.  We can see this logic placed on all of the “Other” war
cry events in the chart.</p>
<p>We also have to feed all of our empathy charts with information anytime we issue
the Advance_War_Cry or the Retreat_Ready_War_Cry.  This is done using an
iterator on the <code class="docutils literal"><span class="pre">other</span></code> object.</p>
<p>Now we get to the meat of the multichart pending pattern.  The horse archers
have to wait until the last of their members have entered the “waiting to lure”
state before they can all perform the false retreat.  So in plain English, when
a horse archer yells that they are ready to retreat, they mentally check to see
if they are the last living member of their unit to give the call.  If so, they
issue the Retreat_War_Cry.</p>
<p>Very similar logic appears in the marshal state.  A horse archer will yell the
Advance_War_Cry if they are the last living member who has entered the “Waiting
to Advance” state.</p>
<p>I was trying to avoid it to save space on our diagram, but there is no way to
avoid it anymore, a horse archer needs to experience time and they need to fire
arrows:</p>
<div align="center" class="align-center"><img alt="_images/ergotic_mongol_51.svg" src="_images/ergotic_mongol_51.svg" /></div>
<p>To track time a horse archer will have a tick attribute which will increment
every second.  We see this implemented as a hook in the outer state.</p>
<p>In the circle and fire state we see that the horse archer rotates in his war
circle every 15 seconds; and depending on his preference he fires 1 to 3 arrows
per shot.  When he has less than 20 arrows he yells out the Skirmish_War_Cry and
together with his unit, they break their circle formation and charge into the
enemy front.</p>
<img alt="_images/mongol-warrior.jpg" class="align-center" src="_images/mongol-warrior.jpg" />
<p>While skirmishing the horse archer is given a chance to make a shot every 3
seconds but only 40 percent of the time does he feel it is worth while to loose
an arrow.  It becomes easier to make a shot during the feigned retreat, so we
say that there is an 80 percent chance to take the shot, every 3 seconds.</p>
<p>Of course these numbers are arbitrary.  Your war bot would be hooked into a set
of sensors and controllers and the feedback would be based on a greater
semblance of reality.  I am putting in these times and probabilities to inject a
bit of chaos into our group tactic, to see if it can hold together in its
path-ish-ness, but it’s just a sketch.</p>
<p>It seems possible for this design to complete a loop; but I can not say for sure
that I have removed all of its accidental oscillations. Once it is written in
code and run a few times we will remove the remaining design bugs.</p>
<p>There are no technical miracles on this page.  The simple snippets of Python in
the map could have been explained to a horse archer using their language.  Their
enemy-lobotomizing swarm behavior can be rendered down into a number of
rectangles, some arrows and a few sentences.  The individual actions required at
each step are also unexceptional.  They are simple things that a horse archer
already knows how to do.  Once we explain Harel formalism and this basic tactic
to our troops and their junior officers, watch out; they will innovate and
improve it until we get something truly remarkable.</p>
</div>
<div class="section" id="encrypted-communications">
<h2>Encrypted Communications<a class="headerlink" href="#encrypted-communications" title="Permalink to this headline">¶</a></h2>
<p>The ergodic nature of are war-bot has a downside.  Once you know how to defeat
one node, you know how to defeat all of them.  Furthermore, the communications
between the bots are fundamental to its system design; if you can inject your
own messaging between them, you will <em>PWN</em> this bot net.</p>
<p>A 13th century European would have not spoken Mongolian, so a Mongol horse
archer would have no problem with intercepted communications.  But, what would
have happened if they had to fight another unit of horse archers?  They would
know what the other side was up to and vise versa.</p>
<p>So it would make sense if each Mongol unit had their own set of war cries.  This
way they could act on an instruction without doubt or hesitation.</p>
<p>The horse archer communications need to be encrypted.  There are many different
ways to do this; it can happen at the communications layer using SSL, or it can
be handled within our war bot directly.</p>
<p>I have opted to use a symmetric encryption scheme with the Fernet library within
our war bot.  I did this after investigating pycryto; which does not
have windows support and has been largely abandon by it’s maintainer.  Don’t use
pycrypt.</p>
<p>Let’s just use Fernet.</p>
<p>Fernet takes a lot of pain out of encryption, but you still need a key.
Encryption is really about key management; how do you keep your key hidden from
your opponent?  Well for now we will hide our key as highlighted plain text on
this website so that everyone on the Internet can see it:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cryptography.fernet</span> <span class="kn">import</span> <span class="n">Fernet</span>

<span class="k">class</span> <span class="nc">Connection</span><span class="p">():</span>
  <span class="nd">@staticmethod</span>
  <span class="k">def</span> <span class="nf">key</span><span class="p">():</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Get the encryption key for this connection.  This key is used for encryption</span>
<span class="sd">    and decryption.</span>

<span class="sd">    Example:</span>
<span class="sd">      key = Connection.key()</span>

<span class="sd">    Note:</span>
<span class="sd">    To generate a new key: Fernet.generate_key()</span>
<span class="sd">    A better way to do this is to get the key from your connected flash-drive.</span>
<span class="sd">    &#39;&#39;&#39;</span>
<span class="hll">    <span class="k">return</span> <span class="sa">b</span><span class="s1">&#39;u3Uc-qAi9iiCv3fkBfRUAKrM1gH8w51-nVU8M8A73Jg=&#39;</span>
</span></pre></div>
</div>
<p>Feeling better already.</p>
<p>To encrypt our data we will use a Python decorator:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cryptography.fernet</span> <span class="kn">import</span> <span class="n">Fernet</span>

<span class="k">class</span> <span class="nc">Connection</span><span class="p">():</span>
  <span class="c1"># ..</span>
  <span class="c1"># ..</span>
  <span class="nd">@staticmethod</span>
  <span class="k">def</span> <span class="nf">encrypt</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A decorator which will encrypt a byte stream prior to transmission:</span>

<span class="sd">    Example:</span>
<span class="sd">      @Connection.serialize</span>
<span class="sd">      @Connection.encrypt   # &lt;- HERE: &#39;message&#39; (encrypted bytestream)</span>
<span class="sd">      def message_to_other_channels(self, message):</span>
<span class="sd">        for channel in self.channels:</span>
<span class="sd">          ip = channel.extension.ip_address</span>
<span class="sd">          channel.basic_publish(exchange=&#39;mirror&#39;,</span>
<span class="sd">              routing_key=ip, body=message)</span>
<span class="sd">          print(&quot; [x] Sent \&quot;{}\&quot; to {}&quot;.format(message, ip))</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_encrypt</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
      <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">      encrypt a byte stream</span>
<span class="sd">      &#39;&#39;&#39;</span>

      <span class="c1"># To get around the &#39;self-as-the-first-argument&#39; issue</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">plain_text</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
      <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">plain_text</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="hll">      <span class="n">f</span> <span class="o">=</span> <span class="n">Fernet</span><span class="p">(</span><span class="n">Connection</span><span class="o">.</span><span class="n">key</span><span class="p">())</span>
</span><span class="hll">      <span class="n">cyphertext</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">encrypt</span><span class="p">(</span><span class="n">plain_text</span><span class="p">)</span>
</span>
      <span class="c1"># To get around the &#39;self-as-the-first-argument&#39; issue</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
<span class="hll">        <span class="n">fn</span><span class="p">(</span><span class="n">cyphertext</span><span class="p">)</span>
</span>      <span class="k">else</span><span class="p">:</span>
<span class="hll">        <span class="n">fn</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cyphertext</span><span class="p">)</span>
</span>    <span class="k">return</span> <span class="n">_encrypt</span>
</pre></div>
</div>
<p>To decrypt we make another decorator:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cryptography.fernet</span> <span class="kn">import</span> <span class="n">Fernet</span>

<span class="k">class</span> <span class="nc">Connection</span><span class="p">():</span>
  <span class="c1"># ..</span>
  <span class="c1"># ..</span>
  <span class="nd">@staticmethod</span>
  <span class="k">def</span> <span class="nf">decrypt</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A decorator which will decrypt a received message into a byte stream.</span>

<span class="sd">    Example:</span>
<span class="sd">      @Connection.decrypt  # &lt;- HERE: &#39;body&#39; decrypted into a byte stream</span>
<span class="sd">      @Connection.deserialize</span>
<span class="sd">      def custom_rx_callback(ch, method, properties, body):</span>
<span class="sd">        print(&quot; [+] {}:{}&quot;.format(method.routing_key, body))</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_decrypt</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">properties</span><span class="p">,</span> <span class="n">cyphertext</span><span class="p">):</span>
      <span class="sd">&#39;&#39;&#39;LocalConsumer.decrypt()&#39;&#39;&#39;</span>
<span class="hll">      <span class="n">f</span> <span class="o">=</span> <span class="n">Fernet</span><span class="p">(</span><span class="n">Connection</span><span class="o">.</span><span class="n">key</span><span class="p">())</span>
</span><span class="hll">      <span class="n">plain_text</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">decrypt</span><span class="p">(</span><span class="n">cyphertext</span><span class="p">)</span>
</span><span class="hll">      <span class="n">fn</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">properties</span><span class="p">,</span> <span class="n">plain_text</span><span class="p">)</span>
</span>    <span class="k">return</span> <span class="n">_decrypt</span>
</pre></div>
</div>
<p>So, we can get a key, we can encrypt and decrypt.  Now, what can we send?  There
is a process in python called pickling which serializes an object into a
collection of bytes.  This collection of bytes can be sent across a network.</p>
<p>Serialization will allow our horse archers to transmit anything within their war
cries.  “Hey Ганболд (Gandbold), do you want one of my extra horses?”, “yes”,
“OK here you go, lala-bee-boop”.  This concept expands on the notion of a war
cry; but it is really cool that we can transmit the objects of working programs,
between the nodes of our botnet.  Of course this is a security nightmare, so if we
are going to serialize and de-serialize messages <em>we will have to use an
encrypted channel</em>.</p>
<p>Now let’s show the serialization technique, it is also implemented using a
decorator:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">miros.event</span> <span class="nn">import</span> <span class="nn">Event</span>

<span class="k">class</span> <span class="nc">Connection</span><span class="p">():</span>
  <span class="c1"># ..</span>
  <span class="c1"># ..</span>

  <span class="nd">@staticmethod</span>
  <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A decorator which will turn arguments into a byte stream prior to encryption:</span>

<span class="sd">    Example:</span>
<span class="sd">      @Connection.serialize  # &lt;- HERE: &#39;message&#39; turned into byte stream</span>
<span class="sd">      @Connection.encrypt</span>
<span class="sd">      def message_to_other_channels(self, message):</span>
<span class="sd">        for channel in self.channels:</span>
<span class="sd">          ip = channel.extension.ip_address</span>
<span class="sd">          channel.basic_publish(exchange=&#39;mirror&#39;,</span>
<span class="sd">              routing_key=ip, body=message)</span>
<span class="sd">          print(&quot; [x] Sent \&quot;{}\&quot; to {}&quot;.format(message, ip))</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_pickle_dumps</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
      <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>

      <span class="c1"># The event object is dynamically constructed and can&#39;t be serialized by</span>
      <span class="c1"># pickle, so we call it&#39;s custom serializer prior to pickling it</span>
<span class="hll">      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">Event</span><span class="p">):</span>
</span><span class="hll">        <span class="n">message</span> <span class="o">=</span> <span class="n">Event</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
</span>
<span class="hll">      <span class="n">pmessage</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">fn</span><span class="p">(</span><span class="n">pmessage</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">fn</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pmessage</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_pickle_dumps</span>
</pre></div>
</div>
<p>The highlighted text in our serialization code demonstrates where the actual
pickling happens.  We see that there is a custom <code class="docutils literal"><span class="pre">dumps</span></code> method written for a
miros Event.  The Event object can’t be serialized with a pickle object because
it uses a simple metaprogramming technique for making new signal names.  No
problem, we just call the Event <code class="docutils literal"><span class="pre">dumps</span></code> method first, then call the pickle
<code class="docutils literal"><span class="pre">dumps</span></code> method on its result.</p>
<p>Now we have a byte stream we can feed our encryption decorator.</p>
<p>How do we turn it back to an object after it has been decrypted?  Well, we
call the <code class="docutils literal"><span class="pre">deserialize</span></code> decorator.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">miros.event</span> <span class="nn">import</span> <span class="nn">Event</span>

<span class="k">class</span> <span class="nc">Connection</span><span class="p">():</span>
  <span class="c1"># ..</span>
  <span class="c1"># ..</span>
  <span class="nd">@staticmethod</span>
  <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A decorator used to turn a serialized byte stream into a python object</span>

<span class="sd">    Example:</span>
<span class="sd">      @Connection.decrypt</span>
<span class="sd">      @Connection.deserialize  # &lt;- HERE: &#39;body&#39; bytestream turn into object</span>
<span class="sd">      def custom_rx_callback(ch, method, properties, body):</span>
<span class="sd">        print(&quot; [+] {}:{}&quot;.format(method.routing_key, body))</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_pickle_loads</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">properties</span><span class="p">,</span> <span class="n">p_plain_text</span><span class="p">):</span>
<span class="hll">      <span class="n">plain_text</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">p_plain_text</span><span class="p">)</span>
</span><span class="hll">      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">plain_text</span><span class="p">,</span> <span class="n">Event</span><span class="p">):</span>
</span><span class="hll">        <span class="n">plain_text</span> <span class="o">=</span> <span class="n">Event</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">plain_text</span><span class="p">)</span>
</span>      <span class="n">fn</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">properties</span><span class="p">,</span> <span class="n">plain_text</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_pickle_loads</span>
</pre></div>
</div>
<p>The de-serialization is just the reverse of the serialization.  We call the
pickle <code class="docutils literal"><span class="pre">loads</span></code> method on the pickled object, then if it is a serialized Event,
we call the custom <code class="docutils literal"><span class="pre">loads</span></code> method of the Event object to get a version of the
event made by the bot that sent it to us in the first place.</p>
<p>Let’s go over everything again from a high level.  If a node in our war bot
wants to share one of its objects with another node, it turns that object into a
byte-stream using the <code class="docutils literal"><span class="pre">serialize</span></code> decorator, encrypts the byte stream with the
<code class="docutils literal"><span class="pre">encrypt</span></code> decorator  and spits some  garbled data onto the network layer.  The
node receiving the data decrypts the stream using the <code class="docutils literal"><span class="pre">decrypt</span></code> decorator,
then turns the byte stream back into the intended Python object using the
<code class="docutils literal"><span class="pre">deserialize</span></code> decorator.</p>
<p>Ok, now what do we do about our secret key?</p>
<p>Our Mongol unit will have a lot of shared experience.  If they don’t follow each
other in their advances and their retreats; they will be killed by their senior
officers.  Maybe we could use this path of actions and the common time
experienced while advancing and retreating to modulate their original secret
key.  In this way we could literally post the key on the Internet for everyone
to see and it wouldn’t matter.  If you wanted to the <em>PWN</em> the bot you would
have to know every action they had taken, when they took it and their modulation
algorithm.</p>
<p>This would be like the Mongol unit making up a new war language every time they
finished a loop.  They would know that if one of their members became
de-synchronized they would never find one another again.</p>
<p>I’m not going to write this into the example; but it is how I would start up my
thinking about this annoying key issue.  I would do the work well after I was
sure the original code was running well.  Then we would have to provide some way
for the botnet to share a common time signal; otherwise NTP poisoning could blow
the entire thing apart.  Also, I’m not sure how the commanding officer would
send messages to our unit either; we have yet another key issue.  Maybe the
botnet could look out at thousands upon thousands of websites, knowing only one
actually has a message from the commanding officer (on craiglist?).  Then inject a
random delay prior to acting on the message.</p>
<p>In this example I demonstrated how to encrypt the data but I exposed the key.
What we have here is security theater, I’m pretending that the system is secure.
It is not; I haven’t solved the key issue.</p>
<p>To give myself a bit more credit; it’s a good start.</p>
<p>Security is hard, the attacker has the advantage; you can’t know when you have
been compromised and you can’t trust anything, from your GPU, to the encryption
standard, to your CPU, it’s all exposed.</p>
<p>The attacker has the advantage, so when in doubt, attack!</p>
</div>
<div class="section" id="instrumenting-to-debug-the-mongol-botnet">
<span id="i-mongol-example-instrumenting-to-debug-the-botnet"></span><h2>Instrumenting to Debug the Mongol Botnet<a class="headerlink" href="#instrumenting-to-debug-the-mongol-botnet" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="implementing-the-mongol-in-miros">
<span id="i-mongol-example-implementing-the-mongol-in-miros"></span><h2>Implementing the Mongol in miros<a class="headerlink" href="#implementing-the-mongol-in-miros" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="examples.html#examples"><span class="std std-ref">back to examples</span></a></p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><p class="logo"><a href="index.html">
  <img class="logo_a" src="_static/miros_a.svg" width="250" alt="Logo" >
</a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Mongol Horse Archer</a><ul>
<li><a class="reference internal" href="#some-historical-context-for-the-example">Some Historical Context For the Example</a></li>
<li><a class="reference internal" href="#deceit-in-detail">Deceit in Detail</a></li>
<li><a class="reference internal" href="#modelling-the-mongol-mind">Modelling the Mongol Mind</a></li>
<li><a class="reference internal" href="#technical-overview">Technical Overview</a></li>
<li><a class="reference internal" href="#designing-the-mongol-in-its-tactic">Designing the Mongol in its Tactic</a></li>
<li><a class="reference internal" href="#encrypted-communications">Encrypted Communications</a></li>
<li><a class="reference internal" href="#instrumenting-to-debug-the-mongol-botnet">Instrumenting to Debug the Mongol Botnet</a></li>
<li><a class="reference internal" href="#implementing-the-mongol-in-miros">Implementing the Mongol in miros</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  <li><a href="examples.html">Examples</a><ul>
      <li>Previous: <a href="networked_instrumentation.html" title="previous chapter">Spy and Trace Across a Network</a></li>
      <li>Next: <a href="recipes.html" title="next chapter">Recipes</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/i_mongol_example.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Scott Volk.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="_sources/i_mongol_example.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>